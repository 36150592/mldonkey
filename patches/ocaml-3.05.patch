diff -r -C 3 ocaml-3.05.orig/asmcomp/compilenv.ml ocaml-3.05/asmcomp/compilenv.ml
*** ocaml-3.05.orig/asmcomp/compilenv.ml	Fri Jun  7 09:35:25 2002
--- ocaml-3.05/asmcomp/compilenv.ml	Wed Aug 14 16:04:47 2002
***************
*** 151,158 ****
    Digest.output oc crc;
    close_out oc
  
! let save_unit_info filename =
!   current_unit.ui_imports_cmi <- Env.imported_units();
    write_unit_info current_unit filename
  
  (* Error report *)
--- 151,158 ----
    Digest.output oc crc;
    close_out oc
  
! let save_unit_info filename units =
!   current_unit.ui_imports_cmi <- units;
    write_unit_info current_unit filename
  
  (* Error report *)
diff -r -C 3 ocaml-3.05.orig/asmcomp/compilenv.mli ocaml-3.05/asmcomp/compilenv.mli
*** ocaml-3.05.orig/asmcomp/compilenv.mli	Fri Feb  8 17:55:30 2002
--- ocaml-3.05/asmcomp/compilenv.mli	Wed Aug 14 16:04:47 2002
***************
*** 65,71 ****
          (* Read infos and CRC from a [.cmx] file. *)
  val write_unit_info: unit_infos -> string -> unit
          (* Save the given infos in the given file *)
! val save_unit_info: string -> unit
          (* Save the infos for the current unit in the given file *)
  
  val cmx_not_found_crc: Digest.t
--- 65,71 ----
          (* Read infos and CRC from a [.cmx] file. *)
  val write_unit_info: unit_infos -> string -> unit
          (* Save the given infos in the given file *)
! val save_unit_info: string -> (string * Digest.t) list -> unit
          (* Save the infos for the current unit in the given file *)
  
  val cmx_not_found_crc: Digest.t
diff -r -C 3 ocaml-3.05.orig/byterun/major_gc.c ocaml-3.05/byterun/major_gc.c
*** ocaml-3.05.orig/byterun/major_gc.c	Wed Jun  5 14:11:15 2002
--- ocaml-3.05/byterun/major_gc.c	Wed Aug 14 16:06:27 2002
***************
*** 126,140 ****
        if (Tag_hd (hd) < No_scan_tag){
          for (i = 0; i < size; i++){
            child = Field (v, i);
-         mark_again:
            if (Is_block (child) && Is_in_heap (child)) {
              hd = Hd_val(child);
              if (Tag_hd (hd) == Forward_tag){
!               child = Forward_val (child);
!               Field (v, i) = child;
!               goto mark_again;
              }
!             if (Tag_hd(hd) == Infix_tag) {
                child -= Infix_offset_val(child);
                hd = Hd_val(child);
              }
--- 126,137 ----
        if (Tag_hd (hd) < No_scan_tag){
          for (i = 0; i < size; i++){
            child = Field (v, i);
            if (Is_block (child) && Is_in_heap (child)) {
              hd = Hd_val(child);
              if (Tag_hd (hd) == Forward_tag){
!               Field (v, i) = Forward_val (child);
              }
!             else if (Tag_hd(hd) == Infix_tag) {
                child -= Infix_offset_val(child);
                hd = Hd_val(child);
              }
***************
*** 192,206 ****
            sz = Wosize_hd (hd);
            for (i = 1; i < sz; i++){
              curfield = Field (cur, i);
!           weak_again:
!             if (curfield != 0 && Is_block (curfield) && Is_in_heap (curfield)
!                 && Is_white_val (curfield)){
                if (Tag_val (curfield) == Forward_tag){
!                 curfield = Forward_val (curfield);
!                 Field (cur, i) = curfield;
!                 goto weak_again;
                }
-               Field (cur, i) = 0;
              }
            }
            weak_prev = &Field (cur, 0);
--- 189,201 ----
            sz = Wosize_hd (hd);
            for (i = 1; i < sz; i++){
              curfield = Field (cur, i);
!             if (curfield != 0 && Is_block (curfield) && Is_in_heap (curfield)){
                if (Tag_val (curfield) == Forward_tag){
!                 Field (cur, i) = Forward_val (curfield);
!               }
!               else if (Is_white_val (curfield){
!                 Field (cur, i) = 0;
                }
              }
            }
            weak_prev = &Field (cur, 0);
diff -r -C 3 ocaml-3.05.orig/driver/optcompile.ml ocaml-3.05/driver/optcompile.ml
*** ocaml-3.05.orig/driver/optcompile.ml	Thu Apr 18 09:27:39 2002
--- ocaml-3.05/driver/optcompile.ml	Wed Aug 14 16:04:47 2002
***************
*** 47,52 ****
--- 47,159 ----
  
  (* Compile a .mli file *)
  
+ let input_lambda = ref false  
+ let output_lambda = ref false
+ 
+   
+ module ObscurLambda = struct
+     open Lambda
+     
+     let find_fv fvs id =
+       try
+         List.assoc id fvs
+       with _ -> id
+     
+     let make_id fvs id = 
+       if not (Ident.persistent id) then
+         let new_id = Ident.create "x" in
+         fvs := (id, new_id) :: !fvs;
+         new_id
+       else
+         id
+     
+     let rec shorten_lambda fvs l = 
+       match l with
+         Lvar id -> Lvar (find_fv fvs id)
+       | Lapply (l1, list) -> 
+           Lapply (shorten_lambda fvs l1, 
+             List.map (shorten_lambda fvs) list)
+       | Lfunction (kind, ids, l1) -> 
+           let fvs = ref fvs in
+           let ids = List.map (make_id fvs) ids in
+           Lfunction (kind, ids, shorten_lambda !fvs l1)
+       | Llet (kind, id, l1, l2) ->
+           let old_fvs = fvs in
+           let fvs = ref fvs in
+           let id = make_id fvs id in
+           Llet(kind, id, shorten_lambda old_fvs l1, 
+             shorten_lambda !fvs l2)
+       | Lletrec (idls, l1) -> 
+           let fvs = ref fvs in
+           let idls = List.map (fun (id, l) ->
+                 make_id fvs id, l) idls in
+           let idls = List.map (fun (id, l) ->
+                 id, shorten_lambda !fvs l) idls in
+           Lletrec (idls, shorten_lambda !fvs l1)
+       | Lprim (prim, list) ->
+           Lprim (prim, List.map (shorten_lambda fvs) list)
+       
+       | Lswitch (l1, sw) -> (* sw contains lambdas *)
+           Lswitch (shorten_lambda fvs l1, 
+             { sw_numconsts = sw.sw_numconsts;
+               sw_consts = List.map (fun (n,l) -> n
+                     , shorten_lambda fvs l) sw.sw_consts;
+               sw_numblocks = sw.sw_numblocks;
+               sw_blocks = List.map (fun (n,l) -> n
+                     , shorten_lambda fvs l) sw.sw_blocks;
+               sw_failaction = match sw.sw_failaction with
+                 None -> None
+               | Some l -> Some (shorten_lambda fvs l);
+             })
+       | Lstaticraise (n, list) ->
+           Lstaticraise (n, List.map (shorten_lambda fvs) list)
+       | Lstaticcatch (l1, (n,ids), l2) ->
+           let old_fvs = fvs in
+           let fvs = ref fvs in
+           let ids = List.map (make_id fvs) ids in
+           Lstaticcatch(shorten_lambda old_fvs l1,
+             (n, ids), shorten_lambda !fvs l2)
+       | Ltrywith (l1, id, l2) ->
+           let old_fvs = fvs in
+           let fvs = ref fvs in
+           let id = make_id fvs id in
+           Ltrywith (shorten_lambda old_fvs l1, id, shorten_lambda !fvs l2)
+       | Lifthenelse (l1, l2, l3) ->
+           Lifthenelse(shorten_lambda fvs l1, shorten_lambda fvs l2,
+             shorten_lambda fvs l3)
+       | Lsequence (l1, l2) ->
+           Lsequence (shorten_lambda fvs l1, shorten_lambda fvs l2)
+       | Lwhile (l1, l2) ->
+           Lwhile (shorten_lambda fvs l1, shorten_lambda fvs l2)
+       | Lfor (id, l1, l2, dir, l3) ->
+           let old_fvs = fvs in
+           let fvs = ref fvs in
+           let id = make_id fvs id in
+           Lfor(id, shorten_lambda old_fvs l1, shorten_lambda old_fvs l2,
+             dir, shorten_lambda !fvs l3)
+       | Lassign (id, l1) ->
+           Lassign(find_fv fvs id, shorten_lambda fvs l1)
+       | Lsend (l1, l2, list) ->
+           Lsend(shorten_lambda fvs l1, shorten_lambda fvs l2, 
+             List.map (shorten_lambda fvs) list)
+       | Levent (l1, event) ->
+           Levent(shorten_lambda fvs l1, event)
+       | Lifused (id, l1) ->
+           Lifused (find_fv fvs id, shorten_lambda fvs l1)
+       | _ -> l
+           
+   end
+   
+ let  save_lambda prefixname (n,l) =
+   if !output_lambda then begin
+       let oc = open_out_bin (prefixname ^ ".lam") in
+       let l = ObscurLambda.shorten_lambda [] l in
+       output_value oc (n,l, Env.imported_units());
+       close_out oc
+     end;
+   (n,l)
+ 
+   
  let interface ppf sourcefile =
    let prefixname = Misc.chop_extension_if_any sourcefile in
    let modulename = String.capitalize(Filename.basename prefixname) in
***************
*** 71,83 ****
  let print_if ppf flag printer arg =
    if !flag then fprintf ppf "%a@." printer arg;
    arg
! 
  let (++) x f = f x
  let (+++) (x, y) f = (x, f y)
  
  let implementation ppf sourcefile =
    let prefixname = Misc.chop_extension_if_any sourcefile in
    let modulename = String.capitalize(Filename.basename prefixname) in
    let inputfile = Pparse.preprocess sourcefile in
    let env = initial_env() in
    Compilenv.reset modulename;
--- 178,203 ----
  let print_if ppf flag printer arg =
    if !flag then fprintf ppf "%a@." printer arg;
    arg
!   
  let (++) x f = f x
  let (+++) (x, y) f = (x, f y)
  
  let implementation ppf sourcefile =
    let prefixname = Misc.chop_extension_if_any sourcefile in
    let modulename = String.capitalize(Filename.basename prefixname) in
+   if !input_lambda then
+     let ic = open_in_bin (prefixname ^ ".lam") in
+     let (n,lam,units) = input_value ic in
+     close_in ic;
+     let env = initial_env() in
+     Compilenv.reset modulename;
+     (n,lam) 
+     +++ print_if ppf Clflags.dump_lambda Printlambda.lambda
+     ++ Asmgen.compile_implementation prefixname ppf ;
+     Compilenv.save_unit_info (prefixname ^ ".cmx") units;
+     Warnings.check_fatal ();
+     
+   else
    let inputfile = Pparse.preprocess sourcefile in
    let env = initial_env() in
    Compilenv.reset modulename;
***************
*** 89,96 ****
      +++ print_if ppf Clflags.dump_rawlambda Printlambda.lambda
      +++ Simplif.simplify_lambda
      +++ print_if ppf Clflags.dump_lambda Printlambda.lambda
      ++ Asmgen.compile_implementation prefixname ppf;
!     Compilenv.save_unit_info (prefixname ^ ".cmx");
      Warnings.check_fatal ();
      Pparse.remove_preprocessed inputfile
    with x ->
--- 209,217 ----
      +++ print_if ppf Clflags.dump_rawlambda Printlambda.lambda
      +++ Simplif.simplify_lambda
      +++ print_if ppf Clflags.dump_lambda Printlambda.lambda
+     ++ save_lambda prefixname
      ++ Asmgen.compile_implementation prefixname ppf;
!     Compilenv.save_unit_info (prefixname ^ ".cmx") (Env.imported_units());
      Warnings.check_fatal ();
      Pparse.remove_preprocessed inputfile
    with x ->
diff -r -C 3 ocaml-3.05.orig/driver/optcompile.mli ocaml-3.05/driver/optcompile.mli
*** ocaml-3.05.orig/driver/optcompile.mli	Tue Mar  7 06:02:32 2000
--- ocaml-3.05/driver/optcompile.mli	Wed Aug 14 16:04:47 2002
***************
*** 22,24 ****
--- 22,27 ----
  
  val initial_env: unit -> Env.t
  val init_path: unit -> unit
+ val output_lambda : bool ref
+ val input_lambda : bool ref
+ 
diff -r -C 3 ocaml-3.05.orig/driver/optmain.ml ocaml-3.05/driver/optmain.ml
*** ocaml-3.05.orig/driver/optmain.ml	Thu Jul 25 17:52:54 2002
--- ocaml-3.05/driver/optmain.ml	Wed Aug 14 16:04:47 2002
***************
*** 168,173 ****
--- 168,175 ----
         "-dscheduling", Arg.Set dump_scheduling, " (undocumented)";
         "-dlinear", Arg.Set dump_linear, " (undocumented)";
         "-dstartup", Arg.Set keep_startup_file, " (undocumented)";
+        "-dol", Arg.Set Optcompile.output_lambda, " (undocumented)";
+        "-dil", Arg.Set Optcompile.input_lambda, " (undocumented)";
         "-", Arg.String (process_file ppf),
              "<file>  Treat <file> as a file name (even if it starts with `-')"
        ] (process_file ppf) usage;
